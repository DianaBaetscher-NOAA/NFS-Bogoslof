---
title: "fecal-mifish-taxonomy-analysis"
author: "dsb"
date: "2024-09-25"
output: github_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Using input data from the Rmd `fecal-mifish-dada2.Rmd` and blastn/taxonkit output from sedna and the eDNA VM.

```{r load-libraries}
library(dplyr)
library(tidyr)
library(stringr)
library(ggplot2)

```

```{r load-output-from-taxonkit}
taxonomy <-read.delim("../data/NFSfecal_mifish_shorttaxlineage.txt", header = FALSE, na.strings=c(""," ","NA"))

head(taxonomy)
```

# clean up the header a bit

```{r}
# use the full taxonomy rather than the seq id to collapse identical entries
tax_df <- taxonomy %>%
  filter(V4 > 100) %>% # make sure all retained matches are >100 bp
  select(-V2, -(V5:V16)) %>%  #remove unnecessary columns
  group_by(V1, V17) %>% # group by the sequence key and the full taxonomy to reduce duplicate entries
  unique() %>% # doing that reduced the number of entries from 146k to 17k
  rename(qseqid=V1, perc_id=V3, length=V4, taxonomy=V17) %>% #rename headers
  filter(!str_detect(taxonomy, "environmental")) %>% # filter out any environmental samples
  filter(!str_detect(taxonomy, "synthetic")) %>% # filter out any synthetic "samples"
  filter(!str_detect(taxonomy, "bacterium")) %>%
  filter(!str_detect(taxonomy, "bacteria")) %>%
  filter(!str_detect(taxonomy, "cultured"))
  #filter(perc_id >= 98) # seems like some of the matches below 98% are dubious (jellyfish and herring <1% different??)
 
```

```{r how-many-total-ASVs-w-taxonomy}
tax_df %>% 
  ungroup() %>%
  select(qseqid) %>%
  unique()
```


### taxonomy clean-up

```{r}
# formatting the taxonomy variables
taxon_df <- tax_df %>%
  filter(str_detect(taxonomy, ";")) %>%
  separate(taxonomy, into=c("kingdom", "phylum", "class", "order", "family", "genus", "species"), sep = ";")

```


Manually dealing with messy hybrid data:
```{r}
fixed_tax_df <- taxon_df %>%
  filter(!str_detect(species, " x ")) %>% # remove hybrids
  filter(!species %in% c("Homo sapiens", "Canis lupus", "Oncorhynchus kawamurae", "Ammodytes japonicus", "Sebastes baramenuke", "Sebastes cheni", "Sebastes inermis", "uncultured bacterium")) %>% # remove species outside of their range
  filter(!str_detect(species, " sp. ")) %>%
  filter(!genus %in% c("Sus", "Bos", "Gorilla")) %>% # remove non-marine mammals
  filter(!order %in% c("Primates"))
  
```

There are four categories:
1. sequences that match a single species unambiguously (the minority)

Sequences that match multiple species are divided in three categories:
2. top matches > 2% identity than second-ranked matches
3. top matches < 2% identity than second-ranked matches
4. Multiple top matches with the same % identity

```{r}
# 1. sequences that are unambiguously a single species
single_spp_seqs <- fixed_tax_df %>% 
  group_by(qseqid) %>%
  add_tally(name = "n_taxa") %>%
  filter(n_taxa == 1)
  
single_spp_seqs
```

```{r}
# remove the single-species seqs from the dataframe and then rank the hits by % identity for the remaining seqs
seq_id_diff <- fixed_tax_df %>%
  anti_join(., single_spp_seqs) %>%
  select(-length) %>%
  group_by(qseqid, species, genus, family, order, class, phylum, kingdom) %>%
    mutate(seq_percID = max(perc_id)) %>%
    group_by(qseqid, species, genus, family, order, class, phylum, kingdom, seq_percID) %>%
  summarise(max(seq_percID)) %>% # take just the top hit for each taxon (for each sequence)
  select(-`max(seq_percID)`) %>%
  ungroup() %>%
  group_by(qseqid) %>%
      mutate(id_rank = rank(desc(seq_percID), ties.method = "min")) %>% # rank the taxonomic hits per sequence by % id
       mutate(top_perc = max(seq_percID)) %>% # designate the highest % id for the best taxonomic hit in each sequence (in some, but not all cases, this is 100%)   
      mutate(diff = top_perc - seq_percID) %>% # calculate the difference between the % identity of the top hit and each subsequent taxonomic hit
        arrange(diff)

seq_id_diff %>%
  filter(diff > 0)
```

Now I have the single best entry for each species for each sequence ranked and with the difference between the first and second ranked entries calculated.

For sequences with multiple top hits, where the difference between ranked taxa = 0, I will end up defaulting to genus- or family-level ID (or carrying the individual species info around in some capacity). I will do the same for any sequences where the difference betweeen the first and second ranked taxa is < 2%.


Figure out which differences are > 2% and eliminate those first?
```{r}
# filter out any taxa that are >2% less matching identity than the top taxonomic hit for a given sequence
to_remove_low_perc_hits <- seq_id_diff %>%
  ungroup() %>%
  group_by(qseqid) %>%
  filter(diff > 2)

keepers <- seq_id_diff %>%
  anti_join(to_remove_low_perc_hits)

```

```{r}
# this data frame includes only those taxonomic hits that should be considered.
# so now I need to determine whether they should be assigned to genus, family, order, etc. 
singletons <- keepers %>%
  select(qseqid) %>%
  tally() %>%
  filter(n == 1)

# these are the seqs that now have only a single match
singleton_df <- singletons %>%
  left_join(keepers) %>%
  select(-n) %>%
  bind_rows(single_spp_seqs) %>% # combine the single spp data
  mutate(taxonomic_level = "species") %>%
  mutate(taxon = species)

## Genus-level matches
# remove the singletons from the bigger df 
single_genus <- keepers %>%
  anti_join(singleton_df)%>% # at best, these should be genus-level matches
  group_by(qseqid, genus) %>%
  tally() %>%
  ungroup() %>%
  group_by(qseqid) %>%
  tally() %>%
  filter(n == 1) %>% # seqs that match a single genus
  select(-n) %>%
  left_join(., keepers) %>%
  mutate(taxonomic_level = "genus") %>%
  mutate(taxon = genus)
  

## Family-level matches
single_family <- keepers %>%
  anti_join(singleton_df)%>%
  anti_join(single_genus) %>%
  group_by(qseqid, family) %>%
  tally() %>%
  ungroup() %>%
  group_by(qseqid) %>%
  tally() %>%
  filter(n == 1) %>% # seqs that match a single family
  select(-n) %>%
  left_join(., keepers) %>%
  mutate(taxonomic_level = "family") %>%
  mutate(taxon = family)


## Order-level matches
single_order <- keepers %>%
  anti_join(singleton_df)%>%
  anti_join(single_genus) %>%
  anti_join(single_family) %>%
  group_by(qseqid, order) %>%
  tally() %>%
  ungroup() %>%
  group_by(qseqid) %>%
  tally() %>%
  filter(n == 1) %>% # seqs that match a single order
  select(-n) %>%
  left_join(., keepers) %>%
  mutate(taxonomic_level = "order") %>%
  mutate(taxon = order)


## Class-level matches
single_class <- keepers %>%
  anti_join(singleton_df)%>%
  anti_join(single_genus) %>%
  anti_join(single_family) %>%
  anti_join(single_order) %>%
  group_by(qseqid, class) %>%
  tally() %>%
  ungroup() %>%
  group_by(qseqid) %>%
  tally() %>% 
  filter(n == 1) %>% # seqs that match a single class
  select(-n) %>%
  left_join(., keepers) %>%
  mutate(taxonomic_level = "class") %>%
  mutate(taxon = class)

# no higher level taxonomy was relevant in this dataset.
```
only 6 ASVs stuck at class


Modify the singleton_df to include the right variable headers
```{r}
single_spp <- singleton_df %>%
  select(-perc_id, -length, -n_taxa) %>%
  mutate(taxonomic_level = "species") %>%
  mutate(taxon = species)

```

```{r}
# recombine the full data set now that the appropriate level of taxonomy has been determined
sorted_tax_df <- bind_rows(single_class, single_order, single_family, single_genus, single_spp)

```

Kim has code to verify that species are within reasonable range/distributions. -- I'm adding that below:

# now let's take a closer look at the assignments we are getting from inital blastn 

## what non-fish are here? 
```{r}
not_Actinopteri <- sorted_tax_df %>%
  filter(class != "Actinopteri") %>%
  select(species, genus, family, order, class, phylum) %>%
  unique()

not_Actinopteri
```
all of those make sense.


## remove terrestrial/freshwater/out-of-range non-fish from data set 
```{r}
# not_Actinopteri_keepers <- not_Actinopteri %>% 
#   #class = Asteroidea - species = Asterias amurensis (North Pacific seastar) - seem reasonable to keep
#   #class = Aves - keeping murre and murrelet
#   filter(order != "Galliformes") %>%  ### remove chicken, junglefowl 
#   filter(species != "Harpagornis moorei") %>% ## definitely no extinct eagle from New Zealand... 
#   #family = Petromyzontidae - lamprey
#   filter(!(family == "Petromyzontidae" & species != "Lethenteron camtschaticum")) %>% ### remove lamprey except Arctic lamprey 
#   #picoplankton
#   filter(species != "Bathycoccus prasinos") %>% ### remove a picoplankton
#   #class = mammals
#   #order = Artiodactyla
#   filter(!family == "Bovidae") %>% ### remove bovids
#   filter(!(family == "Delphinidae" & species != "Lagenorhynchus obliquidens")) %>% ### remove dolphins expect Pacific white-sided 
#   filter(!family == "Suidae") %>% ### remove pigs 
#   filter(!family == "Cervidae") %>% ### remove moose 
#   #order = Carnivora
#   filter(!species == "Pusa sibirica") %>% ### remove Baikal seal 
#   filter(!species == "Pusa caspica") %>% ### remove Caspian seal 
#   filter(!family == "Hominidae") %>% ### remove humans
#   filter(!family == "Canidae") %>% ### remove dog
#   select(species) %>%
#   rename(Species = species) %>%
#   mutate(in_range = "yes")

```

## now look at the fish and figure out what taxa are in/out of our range
```{r}
to_check_range <- sorted_tax_df %>%
  filter(class == "Actinopteri") %>%
  select(species, genus, family, order, class, phylum) %>%
  unique()
```

## check ranges for species using rfishbase 
## also at this step, check 
```{r}
# library(remotes)
# remotes::install_github("ropensci/rfishbase")
# library(rfishbase)
# 
# #one-time download of all fishbase tables... this takes a bit 
# rfishbase::fb_import()
# 
# fb_tables("fishbase")
# 
# #first, validate species names using rfishbase synonyms
# spp_df <- synonyms(to_check_range$species)
# 
# syn <- spp_df %>% 
#   filter(Status == "synonym")
#   
# to_check_range <- to_check_range %>% 
#   mutate(validated_name = ifelse(species %in% syn$synonym, syn$Species, species))
#     
# to_check_range %>%
#   filter(species != validated_name)

# THE DISTRIBUTION FUNCTION ISN'T WORKING FOR ME?
#get distribution info 
# spp_distribution <- distribution(to_check_range$validated_name) %>%
#   select(Species, FAO) %>%
#   unique()

#add column to designate if we will consider a species as "in range"- for this study, this will be NE Pacific and Arctic Ocean 
# spp_distribution_range <- spp_distribution %>%
#   mutate(in_range = ifelse(is.na(FAO), NA, "no"),
#          in_range = ifelse(FAO == "Pacific, Northeast", "yes", in_range),
#          in_range = ifelse(FAO == "Arctic Ocean", "yes", in_range))
# 
# #keep just a list of spp names and yes/no/NA for "in range"  - this way we can keep track of what spp didn't have any reference information in fishbase to determine range 
# spp_range <- spp_distribution_range %>%
#   select(Species, in_range) %>%
#   unique()

#how many entries do not have range info? 
# range_na <- spp_range %>%
#   filter(is.na(in_range))
```

When a valid name was not found, the presence of a species in the study area was checked using the GBIF database (https://www.gbif.org/).

# some species do not have range info - manually determine if these species should be considered in range
```{r}
# range_na <- range_na %>%
#   mutate(in_range = ifelse(Species == "Ammodytes japonicus", "no", in_range),
#          #in_range = ifelse(Species == "Cleisthenes herzensteini", "no", in_range),
#          #in_range = ifelse(Species == "Gadus ogac", "no", in_range),
#          #in_range = ifelse(Species == "Myoxocephalus aenaeas", "no", in_range),
#          #in_range = ifelse(Species == "Kareius bicoloratus", "no", in_range),
#          #in_range = ifelse(Species == "Cottocomephorus grewingki", "no", in_range),
#          in_range = ifelse(Species == "Sebastes cheni", "no", in_range)) #,
#          #in_range = ifelse(Species == "Embassichthys bathybius", "yes", in_range),    ##new name is Microstomus bathybius
#          #in_range = ifelse(Species == "Pungitius kaibarae", "no", in_range),
#          #in_range = ifelse(Species == "Ulcina olrikii", "yes", in_range),  ### arctic alligatorfish - Aspidophoroides olrikii
#          #in_range = ifelse(Species == "Polypera greeni", "yes", in_range))  ## Liparis greeni
```

```{r}
to_check_range
```













Create output taxonomy data frames
```{r output-taxonomy}
uncollapsed_taxonomy <- sorted_tax_df %>%
  select(-top_perc, -id_rank) %>%
  unique()


# quick look at the taxonomy before collapsing it:
uncollapsed_taxonomy

# and then collapse that down to just a single taxon per ASV
collapsed_taxonomy <- uncollapsed_taxonomy %>%
  select(qseqid, taxon, taxonomic_level) %>%
  unique()

# then remove those high level taxonomic assignments that aren't informative
collapsed_taxonomy %>%
  #filter(!taxonomic_level %in% c("class", "order")) %>%
  select(-qseqid) %>%
  unique()


collapsed_taxonomy %>%
  select(-qseqid) %>%
  unique() %>%
  group_by(taxonomic_level) %>%
  tally()

collapsed_taxonomy %>%
  rename(ASV = qseqid) %>%
  write_csv("csv_outputs/fecal_mifish_collapsed_taxonomy.csv")
```

Conservatively, we have 35 species, 23 genera, 10 family-level taxonomic assignments.


#### Read in ASV table ####

```{r}
asv_table <- read.csv("csv_outputs/NFSfecal_MiFish_ASVtable.csv") %>%
  rename(sample = X)

# reformat
sample_df <- asv_table %>%
  pivot_longer(2:length(asv_table), names_to = "ASV", values_to = "reads") %>%
  filter(reads > 0) %>%
  separate(sample, into = c("ablg", "plate", "replicate"), remove = F)

head(sample_df)
```

```{r plate-1}
sample_df %>%
  filter(plate == "plate1") %>%
  filter(reads > 10) %>%
  ggplot(aes(x = ablg, y = reads, fill = ASV)) +
  geom_bar(stat = "identity") +
  facet_grid(rows = vars(replicate)) +
  theme_minimal() +
  theme(
    legend.position = "none",
    axis.text.x = element_text(angle = 90)
  ) +
  labs( 
    title = "NFS fecal samples - plate 1")


```

```{r plate-2}
sample_df %>%
  filter(plate == "plate2") %>%
  filter(reads > 10) %>%
  ggplot(aes(x = ablg, y = reads, fill = ASV)) +
  geom_bar(stat = "identity") +
  facet_grid(rows = vars(replicate)) +
  theme_minimal() +
  theme(
    legend.position = "none",
    axis.text.x = element_text(angle = 90)
  ) +
  labs( 
    title = "NFS fecal samples - plate 2")


```

Just quickly, what are the top species?

```{r combine-data-and-taxonomy}
combined_df <- sample_df %>%
  left_join(., collapsed_taxonomy, by = c("ASV" = "qseqid"))


combined_df %>%
  arrange(desc(reads)) %>%
  filter(!taxon %in% c("Callorhinus ursinus", "Acipenser", "Acipenser fulvescens", "Actinopteri", "uncultured bacterium", "Eumetopias jubatus")) %>%
  group_by(taxon) %>%
  summarise(sum(reads)) %>%
  arrange(desc(`sum(reads)`))


```

```{r}
combined_df %>%
  filter(!taxon %in% c("Callorhinus ursinus", "Acipenser", "Acipenser fulvescens", "Actinopteri", "uncultured bacterium", "Eumetopias jubatus")) %>%
  filter(reads > 10) %>%
  group_by(taxon) %>%
  tally() %>%
  arrange(desc(n))

```

How many sturgeon reads were in the samples? (tag-jumping)
```{r}
combined_df %>%
  filter(taxon == "Acipenser" | taxon == "Acipenser fulvescens") %>%
  filter(!ablg %in% c("PC", "NC") & !replicate %in% c("EB", "FB")) %>%
  arrange(desc(reads)) %>%
  group_by(plate) %>%
  summarise(max(reads))

```

Ok, so as few as 3 reads and as many as 501 in the samples. Not super clean... but we'll proceed for now.
Notably, plates 1 and 3 are very similar, and plate 2 has more apparent cross-contamination/tag-jumping.

```{r}
# what about mean values
combined_df %>%
  filter(taxon == "Acipenser" | taxon == "Acipenser fulvescens") %>%
  filter(!ablg %in% c("PC", "NC") & !replicate %in% c("EB", "FB")) %>%
  arrange(desc(reads)) %>%
  group_by(plate) %>%
  summarise(mean(reads))

```
Interesting! So the mean is actually higher in plate 1.

What's the distribution of read depth across plates though?
```{r}
combined_df %>%
  group_by(plate) %>%
  summarise(mean(reads))

combined_df %>%
  group_by(plate) %>%
  summarise(mean(reads))

#range?
combined_df %>%
  filter(!ablg %in% c("PC", "NC") & !replicate %in% c("EB", "FB")) %>%
  group_by(plate) %>%
  summarise(max(reads))

```
plate 1 has a much higher mean.


## Estimate tag-jumping ##


```{r tag-jumping-by-ASVs-in-PC}
# on a per-plate basis, what % of each ASV should be subtracted from the samples?
asv_prop_df <- combined_df %>%
  filter(!is.na(taxon)) %>%
  group_by(sample) %>%
  mutate(total_reads = sum(reads)) %>%
  mutate(asv_prop = reads/total_reads)
  
asv_prop_df %>%
  filter(ablg == "PC") %>%
  ggplot(aes(x = sample, y = asv_prop, fill = taxon)) +
  geom_bar(stat = "identity") +
  facet_grid(row = vars(replicate)) +
  theme_minimal()

```



```{r which-asv-proportions-to-remove}
# based on asvs in the PC
asv_prop_to_remove <- asv_prop_df %>%
  filter(ablg == "PC") %>%
  ungroup() %>%
  select(plate, ASV, taxon, taxonomic_level, asv_prop) %>%
  rename(prop_to_subtract = asv_prop)

```


```{r remove-asvs-props-from-PC-in-samples}
filtered_sample_df <- asv_prop_df %>%
  left_join(., asv_prop_to_remove) %>%
  mutate(new_asv_prop = ifelse(!is.na(prop_to_subtract), asv_prop-prop_to_subtract, asv_prop)) %>%
  mutate(new_asv_prop = ifelse(new_asv_prop < 0, 0, new_asv_prop)) %>% # remove negative numbers
  filter(new_asv_prop > 0) %>% # remove entries for taxa that we filtered out (human, dog, bacteria, etc.)
  group_by(sample, taxon) %>%
  mutate(taxon_prop = sum(new_asv_prop)) %>%
  select(-new_asv_prop) %>% 
  mutate(taxon_reads = sum(reads)) %>%
  select(-reads, -asv_prop, -prop_to_subtract, -ASV, -total_reads, -taxon_prop) %>%
  filter(taxon != "Acipenser fulvescens") %>% # for some reason this ASV for the PC showed up in one sample.
  # if there are multiple ASVs for a given species, combine those here
  unique() %>% # remove duplicate entries for taxa with multiple ASVs
  # and then recalculate proportions based on the new filtered data for each sample
  ungroup() %>%
  group_by(sample) %>%
  mutate(sample_reads = sum(taxon_reads)) %>%
  mutate(new_tax_prop = taxon_reads/sample_reads)
  

filtered_sample_df
```



```{r consistency-across-extractions-from-the-same-sample?}
# how many samples fell below the 1000 read threshold?
filtered_sample_df %>%
  filter(!ablg %in% c("PC", "NC") & !replicate %in% c("EB", "FB")) %>%
  #filter(plate == "plate3") %>%
  ggplot(aes(x = ablg, y = new_tax_prop, fill = taxon)) +
  geom_bar(stat = "identity") +
  facet_grid(row = vars(plate), cols = vars(replicate)) +
  theme_bw() +
  theme(
    legend.position = "none",
    axis.text.x = element_text(angle = 90)
  ) +
  labs(y = "proportion of reads")
  
ggsave("pdf_outputs/fecal_mifish_filtered_plate_replicates.pdf", width = 10, height = 5)
```



```{r outputs}
# list of species
taxon_list <- filtered_sample_df %>% 
  filter(!ablg %in% c("PC", "NC") & !replicate %in% c("EB", "FB")) %>%
  group_by(taxon) %>%
  summarise(sum(new_tax_prop)) %>%
  arrange(desc(`sum(new_tax_prop)`))
  
taxon_list %>%  
  write.csv("csv_outputs/fecal_mifish_taxon_list_filtered.csv")

# and dataframe
filtered_sample_df %>%
  write.csv("csv_outputs/fecal_mifish_filtered_df.csv")

taxon_list %>%
  filter(taxon != "Callorhinus ursinus") %>%
  select(taxon)

```
Questionable species:
Sardinops? looks like distribution *may* include the aleutians?

```{r}
filtered_sample_df



```


```{r pull-in-metadata}
metadata <- readxl::read_xlsx("../data/NFS_metadata_20241001.xlsx")

data_w_meta <- filtered_sample_df %>%
  left_join(., metadata, by = c("ablg" = "extraction_ID")) %>%
  select(alternative_ID, source, collection_year, collection_month, collection_day, location1, ablg, everything()) %>%
  rename(taxon_proportion_reads = new_tax_prop)


data_w_meta %>%
  write.csv("csv_outputs/NFS_Bogo_fecal_MiFish_data_w_metadata.csv")

```





## Question 1: Are subsamples from the same fecal sample similar/homogenized?

To evaluate this question, we'll want to do a Bray-Curtis.




